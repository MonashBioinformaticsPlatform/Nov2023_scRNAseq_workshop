For this workshop, we'll use the PBMC data object with Monocle for pseudotime trajectory analysis. It's debatable whether this is a suitable dataset but will suit our needs for demonstration purposes.

This content is based off the [Calculating Trajectories with Monocle 3 and Seurat](http://htmlpreview.github.io/?https://github.com/satijalab/seurat-wrappers/blob/master/docs/monocle3.html) material as well the [Monocle3 documentation](https://cole-trapnell-lab.github.io/monocle3/docs/starting/), combining it with the PBMC dataset from the original Seurat vignette. We recommend reading the [Monocle3 documentation](https://cole-trapnell-lab.github.io/monocle3/docs/starting/) for greater understanding of the Monocle package.

Firstly, load Monocle:

```{r , eval = FALSE} 
library(monocle3)
library(SeuratWrappers)
```
As the PBMC data has been processed, we can proceed with converting the pbmc `Seurat` object to a `cell_data_set` object, which is a class from the `Monocle` package. The `as.cell_data_set` function is used from the `SeuratWrappers` library and is used to convert the Seurat object into a `cell_data_set` object.

While we have performed the general analysis steps of quality control, scaling and normalization, dimensionality reduction and clustering with Seurat, Monocle is also capable of performing these steps with its own in-built functions. It is often a matter of preference which package to use, depending on what downstream tasks the analyst would like to perform.

![](https://cole-trapnell-lab.github.io/monocle3/images/monocle3_new_workflow.png)
We aren't going to delve deeply into the properties of the `cell_data_set` object. Just be aware that this is a different way to represent the count assay data and dimensionality reduction data. The functions from the `Monocle` package expects the scRNA data to be this class and therefore, the Seurat object needs to be converted to this class. It also means that the Seurat functions that we've been using will not work with the `cell_data_set` object. 

```{r , eval = FALSE}
cds <- as.cell_data_set(pbmc)
```

While we have previously clustered the pbmc dataset using Seurat, Monocle will also calculate 'partitions' - these are superclusters of the Louvain/Leiden communties that are found using a kNN pruning method. The warning message during the conversion notes that Seurat doesn't calculate partitions and clusters need to be re-calculated using Monocle.

Examine the cds object:

```{r , eval = FALSE}
## Inspect the cds object and compare it to the Seurat pbmc object
cds
```


Now re-cluster the cds object:


```{r , eval = FALSE}
cds <- cluster_cells(cds)
p1 <- plot_cells(cds, show_trajectory_graph = FALSE)
p2 <- plot_cells(cds, color_cells_by = "partition", show_trajectory_graph = FALSE)
wrap_plots(p1, p2)
```

We can see that in the first plot, Monocle has identified 3 clusters but all the clusters fall within the same partition. Ideally, partitions should correspond to clusters of cells within the same path of differentiation or cell within the same trajectory. 

![](https://ars.els-cdn.com/content/image/1-s2.0-S0263931913000495-gr1.jpg)

*Source: [Haematopoiesis and red blood cells](https://www.sciencedirect.com/science/article/pii/S0263931913000495)*

We can see from this figure of haematopoiesis that our PBMC sample contains a mix of cells from different cell types and are unlikely to be suitable for calculating a pseudotime trajectory. Nonetheless, we'll demonstrate the steps involved.

Next, we need to run `learn_graph` to learn the trajectory graph. This function aims to learn how cells transition through a biological program of gene expression changes in an experiment.

```{r , eval = FALSE}
cds <- learn_graph(cds)
plot_cells(cds, label_groups_by_cluster = FALSE, 
           label_leaves = FALSE, 
           label_branch_points = FALSE)
```

As expected from the partition plot, Monocle thinks all the cells are from the same partition and therefore has plotted a trajectory line that connects all clusters. 

Can we fix this?

Monocle currently thinks that all cells belong to the same partition. We might be able to tweak the clustering for a better result. One thing we can think about is that we have a different number of clusters generated by Monocle (3) when Seurat gave us 9.

If we examine the default parameters by `?FindClusters` and `?cluster_cells`, we might notice that Seurat's default clustering algorithm is `louvain` while Monocle's is `leiden`. We aren't going to delve into the details of these algorithms, but we will say, just be aware of the default behavior of your analysis tools and that the choice in algorithm will affect the results of the clustering.

We can change algorithm with `cds <- cluster_cells(cds, cluster_method = "louvain")` but in this case, we might just try altering the resolution with the default `leiden` algorithm to increase the number of clusters yielded. Changing the `k` argument will change the number of nearest neighbors used when creating the k nearest neighbor graph. A large `k` value (the default is 20) reduces the number of clusters (therefore the bigger k is, the less clusters will be generated) and vice versa (smaller `k` value - more clusters). 

```{r , eval = FALSE}
cds <- cluster_cells(cds, k = 5, random_seed = 5)
p1 <- plot_cells(cds, show_trajectory_graph = FALSE)
p2 <- plot_cells(cds, color_cells_by = "partition", show_trajectory_graph = FALSE)
wrap_plots(p1, p2)
```

The UMAP on the left looks under clustered compared to our original clustering with Seurat. We'd probably need to tweak more parameters to get Monocle to match the Seurat clustering. We don't necessarily need to do that because our `cds` object actually still has the meta-data about the Seurat clusters stored in it (examine this with `head(colData(cds))`. However, importantly, our partition plot looks a little more sensible and no longer has lumped all cells into one supercluster. 

Let's re-run the `learn_graph` step:

```{r , eval = FALSE}
cds <- learn_graph(cds)
plot_cells(cds, color_cells_by = "partition", 
           label_groups_by_cluster = FALSE, 
           label_leaves = FALSE, label_branch_points = FALSE)
```

Monocle now 'correctly' builds trajectories that recognizes distinct cell lineages. 

We might choose to remove the B-cells and monocytes and focus just on the cluster of CD4T/CD8T cells, as this is the largest group of cells.

```{r , eval = FALSE}
# Create a vector of idents to keep
selected_ids <- c("Naive CD4 T", "Memory CD4 T", "CD8 T")
tcells_pbmc <- subset(pbmc, idents = selected_ids ) ## subset the PBMC seurat object to tcells
cds <- as.cell_data_set(tcells_pbmc) ## convert this to cell_data_set
cds <- cluster_cells(cds)
cds <- learn_graph(cds) 
plot_cells(cds, label_groups_by_cluster = FALSE, 
           label_leaves = FALSE, label_branch_points = FALSE)
```

The next step is to order cells in pseudotime:

>Pseudotime is a measure of how much progress an individual cell has made through a process such as cell differentiation.
> 
> In many biological processes, cells do not progress in perfect synchrony. In single-cell expression studies of processes such as cell differentiation, captured cells might be widely distributed in terms of progress. That is, in a population of cells captured at exactly the same time, some cells might be far along, while others might not yet even have begun the process. This asynchrony creates major problems when you want to understand the sequence of regulatory changes that occur as cells transition from one state to the next. Tracking the expression across cells captured at the same time produces a very compressed sense of a gene's kinetics, and the apparent variability of that gene's expression will be very high.
> 
> By ordering each cell according to its progress along a learned trajectory, Monocle alleviates the problems that arise due to asynchrony. Instead of tracking changes in expression as a function of time, Monocle tracks changes as a function of progress along the trajectory, which we term "pseudotime". Pseudotime is an abstract unit of progress: it's simply the distance between a cell and the start of the trajectory, measured along the shortest path. The trajectory's total length is defined in terms of the total amount of transcriptional change that a cell undergoes as it moves from the starting state to the end state.
*Source: [Monocle's documentation](https://cole-trapnell-lab.github.io/monocle3/docs/trajectories/#order-cells)*


Monocle needs to be told where the 'beginning' of the biological process is. There are a variety of ways that this can be determined - the Monocle documentation has a custom function to find the root of the trajectory based on a subset of cells. If the `order_cells` function is used without providing which cells to use, it will launch an interface in which we can directly select cells we think are at the beginning of the trajectory.

```{r , eval = FALSE}
# a helper function to identify the root principal points:
get_earliest_principal_node <- function(cds,  cell_type="Naive CD4 T"){
  cell_ids <- which(colData(cds)[, "ident"] == cell_type)
  
  closest_vertex <-
  cds@principal_graph_aux$UMAP$pr_graph_cell_proj_closest_vertex
  closest_vertex <- as.matrix(closest_vertex[colnames(cds), ])
  root_pr_nodes <-
  igraph::V(principal_graph(cds)$UMAP)$name[as.numeric(names
  (which.max(table(closest_vertex[cell_ids,]))))]
  
  root_pr_nodes
}
cds <- order_cells(cds, root_pr_nodes=get_earliest_principal_node(cds))
```

We can now plot the trajectory and color cells by pseudotime:

```{r , eval = FALSE}
plot_cells(cds, color_cells_by = "pseudotime", 
                 label_cell_groups = FALSE, label_leaves = FALSE, 
                 label_branch_points = FALSE)
plot_cells(cds, color_cells_by = "ident", 
                 label_cell_groups = FALSE, label_leaves = FALSE,
                 label_branch_points = FALSE)
```

Discuss the results of this pseudotime trajectory (remembering this is a bogus example):

* CD8T cells are not the furthest cell type from the naive CD4 t-cells
* Naive CD4 T-cells get split into two groups - cells at the root state and 'early' in terms of pseudotime and then cells that are at the end of the pseudotime  timeline
* Would you interpret this as naive CD4 T cells shifting into memory CD4 T-cells then CD8T cells and then back to CD4 naive?
* An analysis tool will always try to give you some sort of answer - it's important to think about whether the tool we're using is appropriate for a given dataset
* What happens if we left in the NK cells?


